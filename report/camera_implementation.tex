\subsection{Single Camera Testing}
After obtaining two of the MT9V034 cameras chosen through the process described in Section \ref{camdecision}, several steps were taken to obtain test images from each camera. These steps are outlined in the following sections.
\par
According to the MT9V034 datasheet, each camera module needs to be supplied with an external Master Clock and Output Enable signal in order to operate \cite{mt9v034}. A simple Verilog module for the Nexys3 Spartan-6 FPGA board was created in order to supply the camera module with a 24MHz master clock signal, and a switch was used to toggle output enable. With this module implemented, the camera module's default outputs could then be observed. In order to interface the camera module with an FPGA, the breakout board shown in Figure \ref{camBreakoutBoard} was also created to make the module's pins more easily accessible. 

\begin{figure}[H]
	\centerline{\includegraphics[width=0.5\textwidth]{camera_board.png}}
	\caption{LI-VM34LP Breakout Board}
	\label{camBreakoutBoard}
\end{figure}

\subsubsection{I$^2$C Control} 
Although the MT9V034 camera control registers are closed source, the previous model's registers are available in the camera module datasheet, and have been found to work with the current model thus far \cite{mt9v032}. As a baseline, the camera module was sent a read request at address 0x00, which should return 0x1324 for the MT9V034 camera module. An oscilloscope screenshot of this request is shown in Figure \ref{camVersion}, with the first packet consisting of a request to address 0x00 of device 0x058, and the second packet consisting of the camera's response of 0x1324. 
\begin{figure}[H]
	\centerline{\includegraphics[width=1.0\textwidth]{oScope/i2c_0x00/tek00001.png}}
	\caption{Example I$^2$C Transfer with Camera}
	\label{camVersion}
\end{figure}

\par
After the camera I$^2$C was deemed working, the camera control register needed to be modified to put the camera in "snapshot" mode. In this mode, the camera module will no longer continuously take pictures, and will only gather new images when an external trigger is activated. This is the mode in which each camera will need to operate in order to acquire stereo imagery, since a shared trigger line will allow for both cameras to be controlled simultaneously.
\par
According to the previous camera iteration's datasheet, the camera module's operational mode can be set through control register 0x07. By default, this register will be set to a value of 0x0388, which corresponds to master mode with parallel output and simultaneous readout of pixel data enabled \cite{mt9v032}. In order to put the camera in trigger mode, the control register needs to be written with value 0x0198, which allows for the same functionality as before with the exception of having continuous shutter mode replaced with an external trigger. For reference, a table with bit descriptions for the camera control register can be found in Appendix item \ref{camctlreg} \cite{mt9v032}.
\par
A button input was then attached to the camera's TRIGGER input line, and the TRIGGER and FRAME\_VALID lines were observed on channels one and two of the oscilloscope, as shown in Figure \ref{camInTrigMode}. This oscilloscope screenshot can be seen as an example of how the camera is no longer in continuous operation, since FRAME\_VALID only asserts itself in response to a TRIGGER input. 
\begin{figure}[H]
	\centerline{\includegraphics[width=1.0\textwidth]{oScope/i2c_0x07/externalTrigger/externalTrig.png}}
	\caption{Camera Trigger and FV in Trigger Mode}
	\label{camInTrigMode}
\end{figure}
\par
In order to prevent accidental modification of the camera module's configuration registers, the register lock feature of the camera I$^2$C bus is also used. By writing 0xDEAD to register 0xFE, it is possible to disable the I$^2$C bus from being written to. This feature is disabled when the power of the camera module is cycled, or by writing 0xBEEF to the register lock register.
\subsubsection{Data Management} 
After successfully creating a camera control interface and placing the MT9V034 camera module in trigger mode, it was then possible to begin viewing images from the module. With the inclusion of the external FIFO module, it is  possible to capture and store an image for future reading, and to read out image data in chunks. Keeping this in mind, the system shown in Figure \ref{camTestBDG} was created for capturing, storing, and transmitting camera images to a computer for external analysis. In order to reduce development time, an external microcontroller was used for controlling the camera module's I$^2$C interface and placing the module in trigger mode. Various buttons and switches on the FPGA were then used for controlling the camera output and trigger, allowing for a user to trigger an image for storage on the AL422B FIFO. Once the image has been stored on the FIFO, the FPGA is capable of reading the image line-by-line into an internal buffer. An internal System on Chip (SoC) is used to control FPGA reads from the FIFO into this internal buffer. An image dump will begin when the SoC microcontroller signals to the FPGA to read a new line of pixels into its internal 8-bit by 752-address pixel buffer. The FPGA will then signal to the microcontroller when this buffer has been filled, and the microcontroller will print out the value of each pixel in the buffer to a connected computer over a Universal Asynchronous Reciever/Transmitter (UART) port. When the microcontroller finishes printing out the value of each pixel in the line buffer, it will signal to the FPGA to read in a new line of pixels. This process will repeat for each of the 480 lines of pixels in the image, allowing for the transmission of an entire image's worth of data from FIFO to computer. The Verilog implementation of the top module and line buffer for this interface can be found in Appendix item \ref{mt9v034TestCode}.

\begin{figure}[H]
	\centerline{\includegraphics[width=1.0\textwidth]{camTestBlockDiag.png}}
	\caption{Camera Test System Block Diagram}
	\label{camTestBDG}
\end{figure}
\par
An example of the transmission of one line of pixel data from the FIFO to the FPGA is shown in Figure \ref{fifoDataOut}.  The green, purple, blue, and yellow lines in this image represent pixel data, FIFO read enable, read reset, and read clock, respectively. Since the FPGA reads in one line of pixel data at a time, this process will take 752 read clock cycles, as measured in Figure \ref{fifoDataOut}. In order to simplify debugging, an internal counter and seven-segment display controller have also been implemented on the FPGA, and will display a running count of the number of pixel lines that have been read into the FPGA's internal buffer, ranging from 0x0000-0x01E0 (0-480). 
\begin{figure}[H]
	\centerline{\includegraphics[width=1.0\textwidth]{oScope/camera_fifo/fifo_rstAndDataTimed.png}}
	\caption{Transferring Line Data from FIFO to FPGA}
	\label{fifoDataOut}
\end{figure}

\subsubsection{Transmitting Images Over UART for Analysis} \label{UARTimg}
Once the FIFO and FPGA line buffer interfaces were created, the source code found in Appendix item \ref{camTestC} was implemented on a Microblaze SoC in order to transmit camera line data from the FPGA's internal line buffer over UART. An example of the microcontroller's UART output is shown in Figure \ref{PuTTYfifoData}. The microcontroller will print the value of each pixel followed by a newline and carriage return, starting with the top left pixel in the acquired image. 
\begin{figure}[H]
	\centerline{\includegraphics[width=0.8\textwidth]{oScope/camera_fifo/PuTTy.png}}
	\caption{Reading FIFO Data}
	\label{PuTTYfifoData}
\end{figure}
\par
After the image is received through PuTTy, the \textsc{Matlab} script found in Appendix item \ref{camTestMatlab} is used to parse the corresponding logfile into a greyscale image. An example image created through this process is shown in Figure \ref{notebookImage}. Note that the sub-optimal quality of this image is due to signal interference and degradation in the test setup's long wiring, as shown in Figure \ref{camTestSetup}. 
\begin{figure}[H]
	\centerline{\includegraphics[width=0.75\textwidth]{oScope/camera_fifo/notebook.png}}
	\caption{Notebook With Grid and Oscilloscope Leads}
	\label{notebookImage}
\end{figure}
\par
Although this system was tested using the Nexys3 (Spartan-6) FPGA board, the use of an external FIFO and little to no platform-specific hardware make it so that it can easily be implemented on any system, including the Zynq family of processors that are used in the final system implementation.   
\begin{figure}[H]
	\centerline{\includegraphics[width=0.75\textwidth]{oScope/camera_fifo/camTestSetup.jpg}}
	\caption{Camera Test Setup}
	\label{camTestSetup}
\end{figure}

\subsection{Final Camera Hardware Implementation}
\subsubsection{Stereo Camera Breakout Board}
After successfully gathering image data from a single camera module, an interface needed to be created for controlling both cameras at once using the ZedBoard. Interfacing each camera module directly to the ZedBoard's GPIO is not feasible, since the pair would consume every available Pmod pin on the board, leaving no additional pins for the IMU or rangefinder\footnote{$[2*(D[9:0]+TRIGGER+OE+RST+SCLK+PCLK+FV+LV)]+SDA+SCL = 36\,\,pins$}. One solution originally investigated was the use of the ZedBoard's FPGA Mezzanine Card (FMC) connector, since it contains 68 available GPIO pins and would be more than adequate for interfacing the stereo cameras with the board. However, the FMC connector has been configured to provide logic voltage levels of only 1.8 or 2.5 volts without modification to the ZedBoard. Since each camera module is only compatible with 3.3 volt logic, the FMC connector is therefore not feasible for our designs.
\par
This leaves the final option of reducing the overall pin count required by the cameras and interfacing the combined camera setup with the board's Pmod pins. One significant method of reducing the necessary pins required is to include an individual AL422B FIFO per camera. Based on the testing described in the previous section, it has already been determined that these FIFO modules are compatible with the MT9V034 cameras, and are capable of significantly reducing memory requirements on the FPGA. A second major advantage of including these FIFO modules in the camera interface is that their data output lines may be placed in a high-impedance state. This means that the individual data output lines of each FIFO module can be connected in parallel, with a single FIFO driving the lines at a time. Since the bulk of each camera module's required pin count lies in its data lines, the ability to connect these lines in parallel reduces the overall camera GPIO requirements by 8 pins. Since each AL422B FIFO module is capable of being read from at a clock speed of up to 50MHz and the maximum master clock rate of each MT9V034 camera module is 27MHz, the inclusion of the FIFO modules also won't cause a significant decrease in the overall speed of the stereo camera system \cite{al422b,mt9v034}.
\par
Along with the shared camera data lines between each AL422B FIFO module, it is also possible to connect several other signals in parallel. Since each camera image capture should be triggered at approximately the same time in a stereo imaging setup, it is already desirable to connect both camera TRIGGER lines together. The RST, OE, SDL, SCA, and SCLK lines of each camera module can also be tied together in pairs of two, and the OE lines can simply be held at 3.3 volts. Lastly, since each camera LV signal must be inverted for use with the AL422B FIFOs, a discrete inverter IC may be used to save on FPGA GPIO. Overall, these modifications will save a total of 25 pins, as shown in Equation \ref{lowerPincount}.
\begin{equation}
\label{lowerPincount}
\begin{split}
36\,\, Pins - (8\,\,Data + 4 \,\,truncated\,\,bits) - (TRIGGER+SCLK+RST) \\ - 2*(OE+PCLK+FV+LV) = 13\,\,pins\,(!) 
\end{split}
\end{equation}
\par
Note each FIFO must be controlled individually, requiring an additional Read Reset (RRST) and Read Enable (RE) pin per camera, as well as a shared Read Clock (RCK) line. This brings the total pin count required by the stereo camera setup to 16 pins plus two I\textsuperscript{2}C pins, which is conveniently the number of GPIO available in two Pmod headers. This setup was implemented as shown in Appendix item \ref{stereoCameraSchematic}, and the final stereo camera breakout board shown in Figure \ref{stereoCameraBoard} was then created.  
\par
A Verilog module was created using a modified version of the MT9V034 camera test code found in Appendix item \ref{mt9v034TestCode} and a VGA controller in order to test the stereo camera breakout board on the Nexys3 platform. A switch input is used to select one of the two camera modules for image aquisition, and a binned 60x92 pixel set from the center of the camera's image is buffered locally for VGA display. The image is then independently written to the display according to internal VGA timing. This process is repeated at a high rate of speed, allowing for a realtime video stream from the selected camera to be displayed. The assembled stereo breakout board used in this test is shown in Figure \ref{stereoTestSetup}.
\begin{figure}[H] 
	\begin{subfigure}{1\textwidth}
	\centering
		\includegraphics[width=0.65\linewidth]{stereo_top.png}
		\caption{PCB Top}
	\end{subfigure}
	\begin{subfigure}{1\textwidth}
	\centering
		\includegraphics[width=0.65\linewidth]{stereo_board_assembled.JPG}
		\caption{Assembled PCB}
	\end{subfigure}
	\caption{Stereo Camera Pmod PCB}
	\label{stereoCameraBoard}
\end{figure}
\par
\begin{figure}[H] 
	\centering
	\includegraphics[width=0.8\linewidth]{stereo_breakout.JPG}
	\caption{Stereo Camera Breakout Under Test}
	\label{stereoTestSetup}
\end{figure}
\par
After attempting to manually focus each camera using the VGA module described above, the code used in Section \ref{UARTimg} was used to transmit image data from the stereo cameras to a computer for further analysis. As you can see from the example image in Figure \ref{newBoardImage} below, the new stereo camera setup is far less susceptible to data loss in comparison to the previous version. For further comparison, please refer back to the test image acquired using the original camera test setup, as shown in Figure \ref{notebookImage}.
\begin{figure}[H] 
	\centering
	\includegraphics[width=0.8\linewidth]{cam1_image.png}
	\caption{Stereo Camera Breakout Sample Image}
	\label{newBoardImage}
\end{figure}

\subsubsection{Image Buffering}
After the camera setup was deemed working based on the results of the Nexys3 test implementation, a finalized camera controller module was created for the ZedBoard. This began with the simple implementation shown in the block diagram in Figure \ref{zedCamTest} below. This implementation contains a customized camera controller IP based around the same code used for creating the camera controller described in Appendix Item \ref{mt9v034TestCode}, with the exception that internal BRAM is used to buffer an entire image captured from the cameras. Note that a custom AXI interface is also included in the test implementation, allowing for the option of reading image data into the Zynq Processing System for more advanced testing and export via PS peripherals such as UART. 
\begin{figure}[H] 
	\centering
	\includegraphics[width=1.0\linewidth]{zedCamTest.PNG}
	\caption{ZedBoard BRAM Camera Test Block Diagram}
	\label{zedCamTest}
\end{figure}
\par
Since a single camera image contains $8 \textrm{ bits} \times (752\times 480)$ pixels, a simple dual-port BRAM module containing $752\times480=360960$ 8-bit addresses was created for storing the output of the AL422B FIFO reader module. Dual-port BRAM was used to allow for external VGA logic to read from the image buffer without the need for read/write protection. Overall, the purpose of this implementation was to test the capabilities of the ZedBoard's internal BRAM for image buffering, as well as to get a simple visual confirmation via VGA output that the implementation was working. An example of the output from this implementation is shown in Figure \ref{bramCamTest} below. 
\begin{figure}[H] 
	\centering
	\includegraphics[width=0.6\linewidth]{bram_test.JPG}
	\caption{ZedBoard BRAM Camera Test}
	\label{bramCamTest}
\end{figure}
\par
After determining that the Zynq Processor's internal BRAM would be usable for storing image data, several tradeoffs associated with the memory requirements of buffering image data in BRAM needed to be addressed. 

\subsubsection{Resource Management} \label{dataman}
One major issue encountered while dealing with resource management on the ZedBoard was the usage of Block RAM. The Zynq7 processor used on the ZedBoard contains 140 individual blocks of 36Kb BRAM, which is equivalent to 630,000 8-bit bytes of memory \cite{zynq7bram}. Although this is plenty of memory for buffering a single 752x480 camera image, three separate image buffers need to be implemented in BRAM for this project. Two of said memory buffers are to be used for storing left and right camera images that are ready to be processed by the disparity algorithm, and a third is to be used for storing a resultant output image that may be displayed via VGA.
\par
In order to address this issue, input camera has been centrally windowed to a resolution of 384x288 pixels, or $0.6\times{}VGA$. The output display buffer has also been reduced from WVGA (752x480) to VGA (640x480). In total, this results in the use of 27 36Kb Block RAM modules for each of the windowed left and right camera images, and 75 36Kb Block RAM modules for the VGA display buffer. Note that each buffer is configured using an individual Block RAM IP, and each consists of a simple dual-port RAM with an 8-bit data length. Overall, this implementation consumes 129 out of the 140 available 36Kb Block RAM modules available on the ZedBoard's Zynq7 processor, leaving additional resources for use in the IMU and rangefinder implementations. 